package o1.subprograms

import o1.*
import scala.math.*

// HERE ARE SOME FUNCTIONS WHICH WE MAKE USE OF IN CHAPTER 1.6.
// You do NOT need to understand their internal workings at that stage.
// The program code below has not been written in a beginner-friendly style.

// DO NOT EDIT THIS FILE. There’s only example code here.
// The code that you’ll write for the programming assignments
// goes in the other files named after "week1" and "week2".


def removeNegatives(numbers: Buffer[Int]): Unit =
  numbers --= numbers.filter( _ < 0 )


private class Movie(val name: String, val year: Int, val rank: Int, val rating: Double, val directors: Seq[String]):
  def isMadeBetween(startYear: Int, endYear: Int) =
    this.year >= startYear && this.year <= endYear

def imdbMovie(rank: Int) = movies.sortBy( _.rank ).apply(rank - 1).name

def imdbBestBetween(startYear: Int, endYear: Int) =
  movies.filter( _.isMadeBetween(startYear, endYear) ).minBy( _.rank ).name

def imdbBestDirectors(minMovieCount: Int) =
  import o1.util.nice.collection.*
  val dirCountPairs = movies.flatMap( _.directors ).frequencies
  val relevantPairs = dirCountPairs.filter( (dir, count) => count >= minMovieCount )
  val dirRanking = relevantPairs.toList.sortBy( (dir, count) => -count )
  dirRanking.map( (dir, count) => s"$dir ($count)" ).mkString(", ")

private lazy val movies =
  val Subdir   = "top_movies"
  val FileName = "omdb_movies_2015.txt"
  val rawLines = o1.util.readFileLines(s"$Subdir/$FileName").getOrElse( throw Exception(s"Could not read the file $FileName, which is expected to be under $Subdir.") )
  val linesAsTokens = rawLines.map( _.split(";") )
  linesAsTokens.map( tokens => Movie(tokens(0), tokens(1).toInt, tokens(2).toInt, tokens(3).toDouble, tokens(4).split(",").toSeq) )


def editDistance(text1: String, text2: String) = o1.util.editDistance(text1, text2, 12)


def canon(song: String, instruments: Iterable[Int], delay: Int) =
  import o1.sound.midi.*
  import o1.util.nice.number.*
  import o1.util.nice.regex.*

  val (melody, tempo) = song match
    case r"(.*?)$melody(?:/([\d]+)$tempoOrNull)?" => (melody, Option(tempoOrNull))

  def initialWait(instrumentNr: Int) = " " * (instrumentNr * delay atLeast 0 atMost melody.length)

  val inCounterpoint = for (instrument, instrumentNr) <- instruments.take(MaxVoices).zipWithIndex
                       yield s"${initialWait(instrumentNr)}[$instrument]$melody"

  inCounterpoint.mkString("&") + tempo.map( "/" + _ ).getOrElse("")
end canon


def censor(text: String, naughtyWords: Iterable[String]) =
  def beep(length: Int) = "[B" + "E" * max(0, length - 2) + "P]"
  def beepOutWord(text: String, word: String) = text.replaceAll(word, beep(word.length))
  naughtyWords.foldLeft(text)(beepOutWord)


def playDoodads(player: String) =
  o1.gui.O1SwingDefaults()
  import o1.gui.Dialog.*
  display(s"Welcome to the game of DOODADS, $player!\nIn the beginning, there are twelve Doodads.\n" +
          "We will take turns choosing to pick up either 1 or 2 Doodads.\nThe one who picks up the last Doodad wins.", Centered)
  LazyList.iterate(12)(playOneRound).takeWhile(gameContinues).force
  display(s"I'm afraid you lost, $player. Sorry about that.\n", Centered)

  def playOneRound(doodadsLeft: Int) =
    requestPick(doodadsLeft).map( humanPick => computerPlays(doodadsLeft - humanPick) ).getOrElse(0)

  def isValidPick(pick: Int) = pick == 1 || pick == 2

  def requestPick(doodadsLeft: Int) =
    requestInt(s"There are $doodadsLeft Doodads remaining. How many will you pick up?", isValidPick, "Please take either 1 or 2.", Centered)

  def computerPlays(doodadsLeft: Int) =
    val computerPick = bestChoice(doodadsLeft)
    display(s"I'll take $computerPick Doodad${(if computerPick == 1 then "" else "s")}.", Centered)
    doodadsLeft - computerPick

  def gameContinues(doodadsLeft: Int) = doodadsLeft > 0
  def bestChoice(doodadsLeft: Int) = doodadsLeft % 3

end playDoodads


def showInfo(word: String) =
  println("The word: " + word + " was received as a parameter.")
  word.length


def volumeOfSphere(radius: Double) = 4 * Pi * pow(radius, 3) / 3


